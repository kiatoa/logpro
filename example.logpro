;; (c) 2006,2007,2008,2009 Matthew Welland matt@kiatoa.com
;;  
;;   License GPL.

;; define your hooks
(hook:add "error"   "echo \"Error hook activated: #{escaped msg}\"" one-time: #t)
(hook:add "warning" "echo \"Got warning: #{escaped warnmsg}\"")
(hook:add "test"    "echo \"m1=#{m1}, m2=#{m2}, m3=#{m3}, m4=#{m4}\"")
(hook:add "freq"    "echo \"Value hook activated: expected=#{expected}, measured=#{measured}, tolerance=#{tolerance}, message=#{message}\"")
(hook:add "logerr"  "echo \"\n\nLog an error: #{line}\n\nmsg: #{msg}\n\"")
;; Capture four values and call four commands
(hook:add "quadval" "echo \"Value1: #{m1}\";echo \"Value2: #{m2}\";echo \"Value3: #{m3}\";echo \"Value4: #{m4}\"") 

;; first ensure your run at least started
;;
(trigger "Init"     #/This is a header/)
(trigger "InitEnd"  #/^\s*$/)
(section "Init" "Init" "InitEnd")

(trigger "Body"     #/^.*$/) ;; anything starts the body
;; (trigger "EndBody"  #/This had better never match/)

(section "Body"     "Body" "EndBody")

(trigger "Blah2"    #/^begin Blah2/)
(trigger "Blah2End" #/^end Blah2/)
(section "Blah2"    "Blah2" "Blah2End")

(expect:required in "Init"  = 1 "Header"      #/This is a header/)
(expect:required in "LogFileBody" > 0 "Something required but not found" #/This is required but not found/)
(expect:value    in "LogFileBody" 1.9 0.1 "Output voltage" #/Measured voltage output:\s*([\d\.\+\-e]+)v/ hook: "freq")
(expect:value    in "LogFileBody" 0.5 0.1 "Output current" #/Measured output current:\s*([\d\.\+\-e]+)mA/)
(expect:value    in "LogFileBody" 110e9 2e9 "A big number (first)" #/Freq:\s*([\d\.\+\-e]+)\s+Hz/)
(expect:value    in "LogFileBody" 110e9 1e9 "A big number (second), hook not called" #/Freq:\s*([\d\.\+\-e]+)Hz/)
(expect:value    in "LogFileBody" 110e9 1e9 "A big number (never activated)" #/Freq:\s*([\d\.\+\-e]+)zH/)

;;                                                          miscellaneous output which doesn't match any expects
(expect:ignore   in "LogFileBody" > 0 "Testing substitution" #/(misc).*(out\S+)\s+(.*ich).*(exp.*)$/ hook: "test")

;; Using match number
(expect:value    in "LogFileBody" 1.9 0.1 "Time Voltage" #/out: (\d+)\s+(\d+)/ matchnum: 2)

;; Comparison instead of tolerance
(expect:value    in "LogFileBody" 1.9 >   "Time voltage" #/out: (\d+)\s+(\d+)/ matchnum: 2)

(expect:ignore   in "Blah2" < 99 "FALSE ERROR" #/ERROR/)
(expect:ignore   in "Body"  < 99 "Ignore the word error in comments" #/^\/\/.*error/)
(expect:warning  in "Body"  = 0 "Any warning" #/WARNING/)
(expect:error    in "Body"  = 0 "ERROR BLAH"  (list #/ERROR/ #/error/) hook: "logerr") ;; but disallow any other errors

;; Use expect:required to extract some values
(expect:required   in "LogFileBody" = 1 "Quad values" #/First:\s+(\d+)\s+Second:\s+(\d+)\s+Third:\s+(\d+)\s+Fourth:\s+(\d+)/ hook: "quadval")

;(expect in "Init"  < 1 "Junk"        #/This is bogus/)
